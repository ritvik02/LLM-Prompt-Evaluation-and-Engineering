import string
import random


SPLITCHARS = set(string.punctuation) | set(string.whitespace) - {'-'}


def locate_concepts(sentence, phrases):
    """
    Get the locations of all instances
    of a specific set of phrases in a sentence.
    """
    last_loc = {phrase: -1 for phrase in phrases}
    locs = {i: set() for i in range(len(sentence))}
    for i in range(len(sentence)):
        for phrase in phrases:
            if last_loc[phrase] > i:
                continue
            loc = sentence.find(phrase, i)
            if loc != -1 and ((loc == 0 or (sentence[loc-1] in SPLITCHARS))
                              and ((loc + len(phrase) == len(sentence))
                              or (sentence[loc+len(phrase)]
                                  in SPLITCHARS))): # noqa
                locs[loc].add(loc + len(phrase))
                last_loc[phrase] = loc
    for i in list(locs.keys()):
        if not locs[i]:
            locs.pop(i)
    return locs


def pairs_to_locs(pairs):
    """
    Convert (start, end) offset pairs to dictionaries
    from start to the set of associated ends.
    """
    locs = {}
    for i, j in pairs:
        if i in locs:
            locs[i].append(j)
        else:
            locs[i] = [j]
    return locs


def hierarchize_concepts(locs):
    """
    Given a dictionary locs from first points of an discrete interval to the
    second point of that interval,
    create a dictionary mapping each interval to all the other intervals it
    contains.
    """
    subconcepts = {}
    js = {}
    for i in sorted(locs.keys()):
        if locs[i]:
            js[i] = []
        else:
            continue
        for j in sorted(locs[i], key=lambda x: -x):
            subconcepts[(i, j)] = set()
            for j_ in js[i]:
                subconcepts[(i, j_)].add((i, j))
            js[i].append(j)
        for i_ in js:
            if i_ == i:
                continue
            k = 0
            j = js[i][0]
            j_ = js[i_][0]
            if j_ < js[i][-1]:
                continue
            for j in js[i]:
                while j_ >= j:
                    subconcepts[(i_, j_)] = subconcepts[(i_, j_)].union(
                        subconcepts[(i, j)]
                                                                       )
                    subconcepts[(i_, j_)].add((i, j))
                    k += 1
                    try:
                        j_ = js[i_][k]
                    except IndexError:
                        break
    return subconcepts


def add_to_dict_of_sets(dict_, key, value):
    """Add a value to a dictionary of sets."""
    if key in dict_:
        if value not in dict_[key]:
            dict_[key].add(value)
    else:
        dict_[key] = {value}


def reverse_dict_of_sets(dict_):
    """Invert a relation defined by a dictionary of sets."""
    reversed_dict = {}
    for key in dict_:
        for value in dict_[key]:
            add_to_dict_of_sets(reversed_dict, value, key)
    return reversed_dict


def deconflict_generator(sentence, subconcepts, resolver, feedback=False):
    """A generator that prunes the subconcepts dictionary generated by
    hierarchize_concepts to eliminate overlapping concepts."""
    subconcepts = subconcepts.copy()
    ancestors = reverse_dict_of_sets(subconcepts)
    while True:
        top_level = [concept
                     for concept in subconcepts
                     if concept not in ancestors or not ancestors[concept]]
        top_level.sort()
        if feedback:
            resolver.deconflict_feedback(top_level)
        cont = False
        last_i = -1
        last_j = -1
        for i, j in top_level:
            if i < last_j:
                yield ((i, j), (last_i, last_j))
                choice = resolver.choice
                if choice is True:
                    prune(ancestors, subconcepts, (last_i, last_j))
                elif choice is False:
                    prune(ancestors, subconcepts, (i, j))
                else:
                    if resolver.choice[0] <= j:
                        prune(ancestors, subconcepts, (i, j))
                    if resolver.choice[1] >= last_i:
                        prune(ancestors, subconcepts, (last_i, last_j))
                    concepts = list(subconcepts.keys()) + [resolver.choice]
                    locs = {}
                    for i, j in concepts:
                        add_to_dict_of_sets(locs, i, j)
                    subconcepts = hierarchize_concepts(locs)
                    ancestors = reverse_dict_of_sets(subconcepts)
                cont = True
                break
            else:
                last_i = i
                last_j = j
        if not cont:
            break


def prune(ancestors, subconcepts, pair):
    """
    Remove all instances of a (start, end) offset pair
    from the ancestors and subconcepts dictionaries.
    """
    if pair in ancestors:
        ancestors.pop(pair)
    for concept in subconcepts.pop(pair):
        if concept in ancestors and pair in ancestors[concept]:
            ancestors[concept].remove(pair)


class DummyModel():
    def __init__(self):
        pass

    def predict(self, input_):
        return random.randint(0, 2)


dummy = DummyModel()


class DummyTagAwareModel():
    def __init__(self, tag_precedence=None):
        self.tag_precedence = tag_precedence
        assert isinstance(tag_precedence, list),\
            'Tag precedence must be specified'

    def predict(self, input_):
        (pair1, tag1, text1), (pair2, tag2, text2) = input_
        if tag1 is None and tag2 is not None:
            return 1
        elif tag1 is not None and tag2 is None:
            return 0
        elif tag1 is None and tag2 is None or tag1 == tag2:
            return random.randint(0, 1)
        elif self.tag_precedence.index(tag1) < self.tag_precedence.index(tag2):
            return 0
        else:
            return 1


def conflict_preprocess(sentence, pair1, pair2, tags):
    if tags is not None:
        return ((pair1, tags.get(pair1), sentence[slice(*pair1)]),
                (pair2, tags.get(pair2), sentence[slice(*pair2)]))
    else:
        return ((pair1, None), (pair2, None))


def mask(term, label_dict):
    if term in label_dict:
        if len(label_dict[term]) == 1:
            return 'imui%d' % next(iter(label_dict[term]))
    return 'XXX'.join(term.split())


class ConflictResolver():
    def __init__(self, model=dummy):
        self.model = model

    def resolve(self, sentence, subconcepts, tags=None):
        for pair1, pair2 in deconflict_generator(sentence,
                                                 subconcepts,
                                                 self,
                                                 True):
            input_ = conflict_preprocess(sentence, pair1, pair2, tags)
            output = self.model.predict(input_)
            if output == 0:
                self.choice = True
            elif output == 1:
                self.choice = False
            elif output == 2:
                self.choice = (pair1[0], pair2[1])
            else:
                raise NotImplementedError('Unknown model output')
        concepts = self.top_level
        concept_tags = [tags[concept] for concept in concepts]
        return concepts, concept_tags

    def deconflict_feedback(self, top_level):
        self.top_level = top_level
